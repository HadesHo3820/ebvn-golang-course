
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/HadesHo3820/ebvn-golang-course/internal/api/api.go (91.7%)</option>
				
				<option value="file1">github.com/HadesHo3820/ebvn-golang-course/internal/api/config.go (85.7%)</option>
				
				<option value="file2">github.com/HadesHo3820/ebvn-golang-course/internal/handler/health_check_handler.go (100.0%)</option>
				
				<option value="file3">github.com/HadesHo3820/ebvn-golang-course/internal/handler/pass_handler.go (100.0%)</option>
				
				<option value="file4">github.com/HadesHo3820/ebvn-golang-course/internal/service/health_check_service.go (100.0%)</option>
				
				<option value="file5">github.com/HadesHo3820/ebvn-golang-course/internal/service/pass_service.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package api provides the HTTP server setup and routing configuration.
// It acts as the entry point for the application, wiring together
// all handlers and services following the Hexagonal Architecture pattern.
package api

import (
        "fmt"
        "net/http"

        "github.com/HadesHo3820/ebvn-golang-course/internal/handler"
        "github.com/HadesHo3820/ebvn-golang-course/internal/service"
        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// Engine defines the interface for the API server.
// It abstracts the server implementation, allowing for easier testing
// and potential swapping of the underlying HTTP framework.
type Engine interface {
        // Start runs the HTTP server on the default port (8080).
        Start() error
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

// api is the concrete implementation of the Engine interface.
// It wraps a Gin engine and manages the application's HTTP routing.
type api struct {
        app *gin.Engine
        cfg *Config
}

// New creates and initializes a new API server.
// It sets up the Gin engine and registers all endpoints.
// Returns an Engine interface to hide the implementation details.
func New(cfg *Config) Engine <span class="cov10" title="2">{
        a := &amp;api{
                app: gin.New(),
                cfg: cfg,
        }
        a.RegisterEP()
        return a
}</span>

// Start begins listening for HTTP requests.
// By default, Gin listens on port 8080.
// Returns an error if the server fails to start.
func (a *api) Start() error <span class="cov0" title="0">{
        return a.app.Run(fmt.Sprintf(":%s", a.cfg.AppPort))
}</span>

// ServeHTTP serves an HTTP request with the given response writer and request.
// It uses the underlying Gin engine to handle the request and write the response.
func (a *api) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov10" title="2">{
        a.app.ServeHTTP(w, r)
}</span>

// RegisterEP sets up all API endpoints and their handlers.
// It performs dependency injection by:
//  1. Creating service instances (business logic layer)
//  2. Injecting services into handlers (HTTP adapter layer)
//  3. Registering handlers with their respective routes
//
// Endpoints:
//   - GET /gen-pass: Generates a random password
//   - GET /health: Health check endpoint
//   - GET /swagger/*any: Swagger UI documentation
func (a *api) RegisterEP() <span class="cov10" title="2">{
        // Initialize the password service (core business logic)
        passSvc := service.NewPassword()

        // Initialize the health check service with config values (Dependency Injection)
        healthSvc := service.NewHealthCheck(a.cfg.ServiceName, a.cfg.InstanceID)

        // Create the password handler with injected service dependency
        passHandler := handler.NewPassword(passSvc)

        // Create the health handler with injected service dependency
        healthHandler := handler.NewHealthCheck(healthSvc)

        // Register the password generation endpoint
        a.app.GET("/gen-pass", passHandler.GenPass)

        a.app.GET("/health-check", healthHandler.Check)

        // Register Swagger documentation endpoint
        a.app.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "github.com/google/uuid"
        "github.com/kelseyhightower/envconfig"
)

type Config struct {
        AppPort     string `default:"8080" envconfig:"APP_PORT"`
        ServiceName string `default:"bookmark-api" envconfig:"SERVICE_NAME"`
        InstanceID  string `default:"" envconfig:"INSTANCE_ID"`
}

func NewConfig() (*Config, error) <span class="cov10" title="2">{
        cfg := &amp;Config{}
        err := envconfig.Process("", cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2">if cfg.InstanceID == "" </span><span class="cov10" title="2">{
                // The most commonly used UUID library for Go is github.com/google/uuid
                cfg.InstanceID = uuid.New().String()
        }</span>
        <span class="cov10" title="2">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package handler provides HTTP handlers for the bookmark service API.
//
// This package implements the presentation layer in a Hexagonal Architecture,
// handling incoming HTTP requests and delegating business logic to the service layer.
// Handlers are responsible for request parsing, response formatting, and HTTP status codes.
package handler

import (
        "net/http"

        "github.com/HadesHo3820/ebvn-golang-course/internal/service"
        "github.com/gin-gonic/gin"
)

// healthCheckResponse represents the JSON response structure for health check endpoints.
//
// Note: In Go, struct fields must be exported (start with an uppercase letter) to be
// accessible via reflection, which is required for JSON serialization. The json tag
// controls the key name in the JSON output, while the example tag provides sample
// values for Swagger documentation.
type healthCheckResponse struct {
        Message     string `json:"message" example:"OK"`
        ServiceName string `json:"service_name" example:"bookmark_service"`
        InstanceID  string `json:"instance_id" example:"instance-123"`
}

// healthCheckHandler is the concrete implementation of the HealthCheck interface.
// It holds a reference to the health check service for performing health status checks.
type healthCheckHandler struct {
        healthCheckSvc service.HealthCheck
}

// HealthCheck defines the interface for health check HTTP handlers.
// This interface allows for dependency injection and easier testing.
type HealthCheck interface {
        // Check handles health check HTTP requests and returns the service status.
        Check(c *gin.Context)
}

// NewHealthCheck creates a new HealthCheck handler with the provided service dependency.
// It follows the constructor injection pattern for dependency management.
//
// Parameters:
//   - svc: The health check service that provides the actual health status logic.
//
// Returns:
//   - HealthCheck: An interface implementation that handles health check HTTP requests.
func NewHealthCheck(svc service.HealthCheck) HealthCheck <span class="cov10" title="3">{
        return &amp;healthCheckHandler{
                healthCheckSvc: svc,
        }
}</span>

// @Summary Health check
// @Description Health check
// @Tags health_check
// @Produce json
// @Success 200 {object} healthCheckResponse
// @Failure 500 {string} Internal Server Error
// @Router /health-check [get]
func (h *healthCheckHandler) Check(c *gin.Context) <span class="cov6" title="2">{
        message, serviceName, instanceID := h.healthCheckSvc.Check()
        c.JSON(http.StatusOK, healthCheckResponse{
                Message:     message,
                ServiceName: serviceName,
                InstanceID:  instanceID,
        })
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "net/http"

        "github.com/HadesHo3820/ebvn-golang-course/internal/service"
        "github.com/gin-gonic/gin"
)

// passwordHandler is the HTTP adapter for password-related operations.
// It implements the Password interface and depends on service.Password
// following the Hexagonal Architecture pattern (Dependency Injection).
type passwordHandler struct {
        svc service.Password
}

// Password defines the interface for password HTTP handlers.
// This acts as a Port in Hexagonal Architecture, allowing the router
// to depend on an abstraction rather than a concrete implementation.
type Password interface {
        // GenPass handles HTTP requests to generate a new password.
        GenPass(c *gin.Context)
}

// NewPassword creates a new password handler with the given password service.
// It accepts service.Password interface to enable loose coupling and testability.
func NewPassword(svc service.Password) Password <span class="cov10" title="4">{
        return &amp;passwordHandler{svc: svc}
}</span>

// GenPass handles the password generation HTTP request.
// It delegates the password generation to the service layer and returns
// the generated password as a plain text response.
//
// @Summary Generate a random password
// @Description Generates a cryptographically secure random password
// @Tags password
// @Produce plain
// @Success 200 {string} string "Generated password"
// @Failure 500 {string} string "Error message"
// @Router /gen-pass [get]
func (h *passwordHandler) GenPass(c *gin.Context) <span class="cov8" title="3">{
        pass, err := h.svc.GeneratePassword()
        if err != nil </span><span class="cov1" title="1">{
                c.String(http.StatusInternalServerError, "err")
                return
        }</span>
        <span class="cov5" title="2">c.String(http.StatusOK, pass)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

const (
        HealthCheckOK = "OK"
)

// healthCheckService holds the configuration values needed for health checks.
type healthCheckService struct {
        serviceName string
        instanceID  string
}

// HealthCheck defines the interface for health check operations.
//go:generate mockery --name HealthCheck --filename health_check_service.go
type HealthCheck interface {
        Check() (string, string, string)
}

// NewHealthCheck creates a new HealthCheck service with the provided config values.
// This follows the Dependency Injection pattern - config is passed in from outside.
func NewHealthCheck(serviceName, instanceID string) HealthCheck <span class="cov10" title="3">{
        return &amp;healthCheckService{
                serviceName: serviceName,
                instanceID:  instanceID,
        }
}</span>

// Check returns the service name, instance ID, and app port.
func (s *healthCheckService) Check() (string, string, string) <span class="cov6" title="2">{
        return HealthCheckOK, s.serviceName, s.instanceID
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "bytes"
        "crypto/rand"
        "math/big"
)

const (
        // charset contains the alphanumeric characters used for password generation.
        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        // passLength defines the default length of the generated password.
        passLength = 10
)

// passwordService implements the Password interface.
type passwordService struct{}

// Password defines the interface for password-related operations.
//go:generate mockery --name Password --filename pass_service.go
type Password interface {
        // GeneratePassword creates a new random password.
        GeneratePassword() (string, error)
}

// NewPassword creates a new instance of the password service.
func NewPassword() Password <span class="cov4" title="3">{
        return &amp;passwordService{}
}</span>

// GeneratePassword generates a cryptographically secure random password.
// It uses characters from the predefined charset and has a fixed length of 10.
// Returns the generated password string or an error if the random number generator fails.
func (s *passwordService) GeneratePassword() (string, error) <span class="cov3" title="2">{
        var strBuilder bytes.Buffer

        // generate random password of length passLength
        for range passLength </span><span class="cov10" title="20">{
                // Generate a random index using crypto/rand for cryptographic security.
                randomIndex, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // Select the character at the random index and append it to the result.
                <span class="cov10" title="20">strBuilder.WriteByte(charset[randomIndex.Int64()])</span>
        }
        <span class="cov3" title="2">return strBuilder.String(), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
