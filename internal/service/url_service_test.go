// Package service contains unit tests for the URL shortening service.
// These tests use mocks to isolate the service logic from the repository layer.
package service

import (
	"context"
	"errors"
	"testing"

	"github.com/HadesHo3820/ebvn-golang-course/internal/repository/mocks"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	mockKeyGen "github.com/HadesHo3820/ebvn-golang-course/pkg/stringutils/mocks"
)

// testErr is a sentinel error used across test cases
// for consistent error comparison.
var testErr = errors.New("test error")

// TestShortenUrl_ShortenUrl validates the ShortenUrl method of the ShortenUrl service.
// It uses table-driven tests to cover various scenarios including success,
// collision handling, and error cases.
func TestShortenUrl_ShortenUrl(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		name            string
		setupMockRepo   func(ctx context.Context, urlInput string, expInput int) *mocks.UrlStorage
		setupMockKeyGen func() *mockKeyGen.KeyGenerator
		urlInput        string
		exp             int    // expiration time in seconds (0 means no expiration)
		expectCode      string // expected code to be returned
		expectedErr     error  // expected error (nil for no error)
	}{
		{
			name: "successful storage on first attempt",
			setupMockRepo: func(ctx context.Context, urlInput string, expInput int) *mocks.UrlStorage {
				mockRepo := mocks.NewUrlStorage(t)
				// First call succeeds (stored = true)
				// We only use mock.Anything to match any argument that is not defined in the test case
				// For example, the StoreUrlIfNotExists method has 4 arguments:
				// ctx, urlCode, url, exp
				// The urlCode is generated by the service and cannot be predicted, so we use mock.Anything to match any argument
				mockRepo.On("StoreUrlIfNotExists", ctx, mock.Anything, urlInput, expInput).
					Return(true, nil).Once()
				return mockRepo
			},
			setupMockKeyGen: func() *mockKeyGen.KeyGenerator {
				m := mockKeyGen.NewKeyGenerator(t)
				m.On("GenerateCode", urlCodeLength).
					Return("1234567", nil).Once()
				return m
			},
			urlInput:    "https://example.com",
			exp:         0,
			expectCode:  "1234567",
			expectedErr: nil,
		},
		{
			name: "successful storage after one collision",
			setupMockRepo: func(ctx context.Context, urlInput string, expInput int) *mocks.UrlStorage {
				mockRepo := mocks.NewUrlStorage(t)
				// First call: collision (stored = false)
				mockRepo.On("StoreUrlIfNotExists", ctx, mock.Anything, urlInput, expInput).
					Return(false, nil).Once()
				// Second call: success (stored = true)
				mockRepo.On("StoreUrlIfNotExists", ctx, mock.Anything, urlInput, expInput).
					Return(true, nil).Once()
				return mockRepo
			},
			setupMockKeyGen: func() *mockKeyGen.KeyGenerator {
				m := mockKeyGen.NewKeyGenerator(t)
				// Called twice: once for collision, once for success
				m.On("GenerateCode", urlCodeLength).
					Return("1234567", nil).Twice()
				return m
			},
			urlInput:    "https://example.com",
			exp:         3600,
			expectCode:  "1234567",
			expectedErr: nil,
		},
		{
			name: "max retries exceeded - all collisions",
			setupMockRepo: func(ctx context.Context, urlInput string, expInput int) *mocks.UrlStorage {
				mockRepo := mocks.NewUrlStorage(t)
				// All 5 attempts result in collision
				mockRepo.On("StoreUrlIfNotExists", ctx, mock.Anything, urlInput, expInput).
					Return(false, nil).Times(5)
				return mockRepo
			},
			setupMockKeyGen: func() *mockKeyGen.KeyGenerator {
				mockKeyGen := mockKeyGen.NewKeyGenerator(t)
				mockKeyGen.On("GenerateCode", urlCodeLength).
					Return("1234567", nil).Times(5)
				return mockKeyGen
			},
			urlInput:    "https://example.com",
			exp:         0,
			expectCode:  "",
			expectedErr: errors.New("failed to generate unique code after 5 attempts"),
		},
		{
			name: "repository error",
			setupMockRepo: func(ctx context.Context, urlInput string, expInput int) *mocks.UrlStorage {
				mockRepo := mocks.NewUrlStorage(t)
				mockRepo.On("StoreUrlIfNotExists", ctx, mock.Anything, urlInput, expInput).
					Return(false, errors.New("redis connection failed")).Once()
				return mockRepo
			},
			setupMockKeyGen: func() *mockKeyGen.KeyGenerator {
				mockKeyGen := mockKeyGen.NewKeyGenerator(t)
				mockKeyGen.On("GenerateCode", urlCodeLength).
					Return("1234567", nil).Once()
				return mockKeyGen
			},
			urlInput:    "https://example.com",
			exp:         0,
			expectCode:  "",
			expectedErr: errors.New("redis connection failed"),
		},
		{
			name:     "KeyGen error",
			urlInput: "https://example.com",
			setupMockRepo: func(ctx context.Context, urlInput string, expInput int) *mocks.UrlStorage {
				mockRepo := mocks.NewUrlStorage(t)
				return mockRepo
			},
			setupMockKeyGen: func() *mockKeyGen.KeyGenerator {
				mockKeyGen := mockKeyGen.NewKeyGenerator(t)
				mockKeyGen.On("GenerateCode", urlCodeLength).
					Return("", testErr).Once()
				return mockKeyGen
			},
			expectedErr: testErr,
			expectCode:  "",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			ctx := t.Context()

			// Setup
			mockRepo := tc.setupMockRepo(ctx, tc.urlInput, tc.exp)
			mockKeyGen := tc.setupMockKeyGen()
			service := NewShortenUrl(mockRepo, mockKeyGen)

			// Execute
			code, err := service.ShortenUrl(ctx, tc.urlInput, tc.exp)

			// Assert
			assert.Equal(t, tc.expectCode, code)
			assert.Equal(t, err, tc.expectedErr)
		})
	}
}
